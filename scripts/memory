#!/usr/bin/env python3
"""AgenticOS memory viewer.

Default behavior: prints a concise summary of:
- Last session (last-session.md)
- Profile memory (profiles/<profile>.md)
- Latest session file for that profile (sessions/YYYY-MM-DD-<profile>.md)

Upgrades:
- Status summary: detects placeholder Next actions / Artifacts sections.
- --paths: prints resolved paths used.
- --open {last|profile|session}: opens selected file cross-platform.
"""

import argparse
import datetime as dt
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional

ROOT = Path(__file__).resolve().parent.parent
VENV_PY = ROOT / ".venv" / "bin" / "python"

# Auto-switch into the AgenticOS venv if it exists and we're not already in it
if not os.environ.get("VIRTUAL_ENV") and VENV_PY.exists() and Path(sys.executable) != VENV_PY:
    os.execv(str(VENV_PY), [str(VENV_PY)] + sys.argv)

MEMORY_ROOT = ROOT / ".agents" / "memory"
LAST_SESSION_FILE = MEMORY_ROOT / "last-session.md"
PROFILES_DIR = MEMORY_ROOT / "profiles"
SESSIONS_DIR = MEMORY_ROOT / "sessions"
WORKFLOW_DIR = MEMORY_ROOT / "workflows"

PLACEHOLDER_NEXT = "(Fill in next actions here.)"
PLACEHOLDER_ARTIFACTS = "(Update manually or via future automation.)"


def read_text(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8", errors="replace")
    except FileNotFoundError:
        return ""


def read_tail(path: Path, max_lines: int = 40) -> List[str]:
    """Return up to max_lines from the end of the file, or [] if missing."""
    text = read_text(path)
    if not text:
        return []
    lines = text.splitlines()
    if len(lines) > max_lines:
        return [f"(truncated; showing last {max_lines} lines)", ""] + lines[-max_lines:]
    return lines


def find_latest_session(profile: str) -> Optional[Path]:
    """Return the newest session file for this profile, or None."""
    if not SESSIONS_DIR.exists():
        return None
    candidates = sorted(SESSIONS_DIR.glob(f"*{profile}.md"))
    if not candidates:
        return None
    return candidates[-1]


def print_section(title: str, lines: List[str]) -> None:
    print(f"=== {title} ===")
    if not lines:
        print("(no data)")
    else:
        for line in lines:
            print(line)
    print()


def status_from_last_session(last_text: str) -> str:
    if not last_text:
        return "Status: No last-session.md found."

    def _next_actions_filled(text: str) -> bool:
        lines = text.splitlines()
        start = None
        for idx, line in enumerate(lines):
            if line.strip().lower().startswith("## next actions"):
                start = idx + 1
                break
        if start is None:
            return False
        end = len(lines)
        for idx in range(start, len(lines)):
            if lines[idx].startswith("## "):
                end = idx
                break
        block = lines[start:end]
        for entry in block:
            stripped = entry.strip()
            if not stripped:
                continue
            if PLACEHOLDER_NEXT in stripped:
                continue
            # Any non-placeholder content counts as filled
            return True
        return False

    has_next_placeholder = PLACEHOLDER_NEXT in last_text
    next_filled = _next_actions_filled(last_text)
    has_artifacts_placeholder = PLACEHOLDER_ARTIFACTS in last_text

    next_status = "looks filled" if next_filled else ("needs update" if has_next_placeholder else "needs update")
    art_status = "needs update" if has_artifacts_placeholder else "looks filled"

    return f"Status: Next actions → {next_status} | Artifacts touched → {art_status}"


def open_file(path: Path) -> int:
    if not path.exists():
        print(f"ERROR: file does not exist: {path}")
        return 2

    # macOS
    if sys.platform == "darwin":
        cmd = ["open", str(path)]
    else:
        # Linux / other
        cmd = ["xdg-open", str(path)]

    try:
        return subprocess.call(cmd)
    except FileNotFoundError as exc:
        print(f"ERROR: open command not found: {exc}")
        return 127


def detect_memory_root(src: Path) -> Path:
    if src.is_file():
        if src.name in {"last-session.md", "summary.md"}:
            return src.parent
        if src.parent.name in {"profiles", "workflows"}:
            return src.parent.parent
    candidates = [
        src / ".agents" / "memory",
        src / "memory",
        src,
    ]
    for cand in candidates:
        if (cand / "last-session.md").exists() or (cand / "summary.md").exists() or (cand / "profiles").exists():
            return cand
    raise FileNotFoundError(f"Could not locate a memory root under {src}")


def queue_action(actions: List[str], dry_run: bool, desc: str) -> None:
    prefix = "[dry-run] " if dry_run else ""
    actions.append(f"{prefix}{desc}")


def import_file(src: Path, dest: Path, label: str, force: bool, dry_run: bool, actions: List[str], timestamp: str) -> None:
    if not src.exists():
        return
    data = src.read_text(encoding="utf-8", errors="replace")
    if not data.strip():
        return
    provenance = f"\n\n## Imported from {src} on {timestamp}\n\n"
    mode = "a"
    if force or not dest.exists():
        mode = "w"
    desc = f"{'replace' if mode == 'w' and dest.exists() else 'append'} {label}: {dest} (from {src})"
    queue_action(actions, dry_run, desc)
    if dry_run:
        return
    dest.parent.mkdir(parents=True, exist_ok=True)
    with dest.open(mode, encoding="utf-8") as fh:
        fh.write(provenance + data)


def perform_import(src: Path, force: bool, dry_run: bool) -> int:
    try:
        root = detect_memory_root(src)
    except FileNotFoundError as exc:
        print(f"ERROR: {exc}")
        return 2

    timestamp = dt.datetime.now(dt.UTC).isoformat() + "Z"
    actions: List[str] = []

    import_file(root / "last-session.md", LAST_SESSION_FILE, "last-session", force, dry_run, actions, timestamp)
    import_file(root / "summary.md", MEMORY_ROOT / "summary.md", "summary.md", force, dry_run, actions, timestamp)

    src_profiles = root / "profiles"
    if src_profiles.exists():
        for profile_path in src_profiles.glob("*.md"):
            dest = PROFILES_DIR / profile_path.name
            import_file(profile_path, dest, f"profile:{profile_path.name}", force, dry_run, actions, timestamp)

    src_workflows = root / "workflows"
    if src_workflows.exists():
        for wf_path in src_workflows.glob("*.md"):
            dest = WORKFLOW_DIR / wf_path.name
            import_file(wf_path, dest, f"workflow:{wf_path.name}", force, dry_run, actions, timestamp)

    if not actions:
        print("Nothing to import.")
        return 0

    print("Import actions:")
    for act in actions:
        print(f"- {act}")
    if dry_run:
        print("Dry run complete. Re-run without --dry-run to apply.")
    return 0


def main() -> None:
    parser = argparse.ArgumentParser(description="AgenticOS memory inspector")
    parser.add_argument(
        "--profile",
        "-p",
        default="dev",
        help="Profile name to inspect (default: dev)",
    )
    parser.add_argument(
        "--lines",
        "-n",
        type=int,
        default=40,
        help="Max lines to show from each section (default: 40)",
    )
    parser.add_argument(
        "--paths",
        action="store_true",
        help="Print resolved paths used for last/profile/session memory files",
    )
    parser.add_argument(
        "--open",
        choices=["last", "profile", "session"],
        help="Open a memory file (cross-platform) and exit",
    )
    parser.add_argument(
        "--import",
        dest="import_path",
        help="Import memory from another project (path to memory root or file)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Allow overwriting files during import (default: append-only)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show planned import actions without writing",
    )
    args = parser.parse_args()

    if args.import_path:
        src = Path(args.import_path).expanduser()
        exit_code = perform_import(src, args.force, args.dry_run)
        sys.exit(exit_code)

    profile_file = PROFILES_DIR / f"{args.profile}.md"
    latest_session = find_latest_session(args.profile)

    # If user requested open, do it and exit early
    if args.open:
        target = {
            "last": LAST_SESSION_FILE,
            "profile": profile_file,
            "session": latest_session,
        }[args.open]

        if target is None:
            print("ERROR: no session file found to open.")
            sys.exit(2)

        result = open_file(target)
        if result == 0:
            print(f"Opened: {target}")
        sys.exit(result)

    print("AgenticOS memory summary")
    print(f"Root      : {ROOT}")
    print(f"Profile   : {args.profile}")
    print(f"Memory dir: {MEMORY_ROOT}")

    last_text = read_text(LAST_SESSION_FILE)
    print(status_from_last_session(last_text))
    print()

    if args.paths:
        print("Resolved paths")
        print(f"- last   : {LAST_SESSION_FILE}")
        print(f"- profile: {profile_file}")
        print(f"- session: {latest_session if latest_session else '(none)'}")
        print()

    # Last session
    last_lines = read_tail(LAST_SESSION_FILE, args.lines)
    print_section("Last session (last-session.md)", last_lines)

    # Profile memory
    profile_lines = read_tail(profile_file, args.lines)
    print_section(f"Profile memory (profiles/{args.profile}.md)", profile_lines)

    # Latest session file for this profile
    if latest_session is not None:
        latest_lines = read_tail(latest_session, args.lines)
        print_section(f"Latest session file ({latest_session.name})", latest_lines)
    else:
        print_section("Latest session file", [])


if __name__ == "__main__":
    main()
